# -*- coding: utf-8 -*-
"""Assignment-3: Trees

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15EAR-tw8xzUaYCic4iIoHyzN7ZUGSoJP
"""

#1)Implement Binary tree
class Node:
    def __init__(self, value=None):
        self.left = None
        self.right = None
        self.value = value

class BinaryTree:
    def __init__(self, root=None):
        self.root = Node(root)

    def insert(self, value):
        if self.root.value is None:
            self.root = Node(value)
        else:
            self._insert(value, self.root)

    def _insert(self, value, node):
        if value < node.value:
            if node.left is None:
                node.left = Node(value)
            else:
                self._insert(value, node.left)
        else:
            if node.right is None:
                node.right = Node(value)
            else:
                self._insert(value, node.right)

    def print_tree(self, traversal_type):
        if traversal_type == "inorder":
            self._inorder_print(self.root)
        elif traversal_type == "preorder":
            self._preorder_print(self.root)
        elif traversal_type == "postorder":
            self._postorder_print(self.root)
        else:
            print("Traversal type " + str(traversal_type) + " is not supported.")

    def _inorder_print(self, node):
        if node:
            self._inorder_print(node.left)
            print(str(node.value), end=" ")
            self._inorder_print(node.right)

    def _preorder_print(self, node):
        if node:
            print(str(node.value), end=" ")
            self._preorder_print(node.left)
            self._preorder_print(node.right)

    def _postorder_print(self, node):
        if node:
            self._postorder_print(node.left)
            self._postorder_print(node.right)
            print(str(node.value), end=" ")

tree = BinaryTree(1)
tree.insert(2)
tree.insert(3)
tree.insert(4)
tree.insert(5)
tree.print_tree("inorder") 
tree.print_tree("preorder") 
tree.print_tree("postorder")

#2)Find height of a given tree
def height(node):
    if node is None:
        return 0
    else:
        left_height = height(node.left)
        right_height = height(node.right)
        return max(left_height, right_height) + 1
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

# calculate the height of the tree
tree_height = height(root)
print("The height of the tree is:", tree_height)

#3)Perform Pre-order, Post-order, In-order traversal
def preorder(node):
    if node is not None:
        print(node.value, end=" ")
        preorder(node.left)
        preorder(node.right)

def inorder(node):
    if node is not None:
        inorder(node.left)
        print(node.value, end=" ")
        inorder(node.right)

def postorder(node):
    if node is not None:
        postorder(node.left)
        postorder(node.right)
        print(node.value, end=" ")
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

# perform pre-order traversal
print("Pre-order traversal:")
preorder(root)
print()

# perform in-order traversal
print("In-order traversal:")
inorder(root)
print()

# perform post-order traversal
print("Post-order traversal:")
postorder(root)
print()

#4)Function to print all the leaves in a given binary tree
def print_leaves(node):
    if node is not None:
        if node.left is None and node.right is None:
            print(node.value, end=" ")
        print_leaves(node.left)
        print_leaves(node.right)
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)
root.right.right.left = Node(8)

# print the leaves of the tree
print("The leaves of the tree are:")
print_leaves(root)

#5)Implement BFS (Breath First Search) and DFS (Depth First Search)
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

def bfs(root):
    if root is None:
        return
    
    queue = [root]  # use a queue to store nodes to visit
    while queue:
        node = queue.pop(0)
        print(node.value, end=" ")
        if node.left is not None:
            queue.append(node.left)
        if node.right is not None:
            queue.append(node.right)

def dfs_preorder(node):
    if node is not None:
        print(node.value, end=" ")
        dfs_preorder(node.left)
        dfs_preorder(node.right)

def dfs_inorder(node):
    if node is not None:
        dfs_inorder(node.left)
        print(node.value, end=" ")
        dfs_inorder(node.right)

def dfs_postorder(node):
    if node is not None:
        dfs_postorder(node.left)
        dfs_postorder(node.right)
        print(node.value, end=" ")
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

# perform breadth-first search
print("BFS:")
bfs(root)
print()

# perform depth-first searches
print("DFS pre-order:")
dfs_preorder(root)
print()
print("DFS in-order:")
dfs_inorder(root)
print()
print("DFS post-order:")
dfs_postorder(root)
print()

#6)Find sum of all left leaves in a given Binary Tree
def sum_left_leaves(root):
    if root is None:
        return 0

    left_sum = sum_left_leaves(root.left)
    right_sum = sum_left_leaves(root.right)

    if root.left is not None and root.left.left is None and root.left.right is None:
        # the current node is a left leaf, add its value to the sum
        return root.left.value + left_sum + right_sum
    else:
        # the current node is not a left leaf, continue traversing
        return left_sum + right_sum
# create a binary tree
root = Node(3)
root.left = Node(9)
root.right = Node(20)
root.right.left = Node(15)
root.right.right = Node(7)
root.left.left = Node(4)

# find the sum of the left leaves of the tree
sum = sum_left_leaves(root)
print("The sum of the left leaves of the tree is:", sum)

#7)Find sum of all nodes of the given perfect binary tree
def sum_nodes_perfect_binary_tree(height):
    return (2 ** (height + 1)) - 1
# calculate the sum of all nodes in a perfect binary tree of height 3
sum = sum_nodes_perfect_binary_tree(3)
print("The sum of all nodes in a perfect binary tree of height 3 is:", sum)

#8)Count subtress that sum up to a given value x in a binary tree
def count_subtrees_with_sum(root, x):
    count = [0]

    def dfs(root):
        if root is None:
            return 0

        left_sum = dfs(root.left)
        right_sum = dfs(root.right)

        subtree_sum = root.value + left_sum + right_sum
        if subtree_sum == x:
            count[0] += 1

        return subtree_sum

    dfs(root)
    return count[0]
# create a binary tree
root = Node(5)
root.left = Node(4)
root.right = Node(8)
root.left.left = Node(11)
root.left.left.left = Node(7)
root.left.left.right = Node(2)
root.right.left = Node(13)
root.right.right = Node(4)
root.right.right.right = Node(1)

# count the number of subtrees with sum 22
count = count_subtrees_with_sum(root, 22)
print("The number of subtrees with sum 22 is:", count)

#9)Find maximum level sum in Binary Tree
def max_level_sum(root):
    if root is None:
        return 0

    level_sum = 0
    max_sum = float('-inf')

    q = [root]
    while q:
        level_sum = 0
        size = len(q)
        for i in range(size):
            node = q.pop(0)
            level_sum += node.value

            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)

        max_sum = max(max_sum, level_sum)

    return max_sum
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

# find the maximum level sum
max_sum = max_level_sum(root)
print("The maximum level sum is:", max_sum)

#10)Print the nodes at odd levels of a tree
def print_odd_level_nodes(root, level=1):
    if root is None:
        return

    if level % 2 == 1:
        print(root.value)

    print_odd_level_nodes(root.left, level+1)
    print_odd_level_nodes(root.right, level+1)
# create a binary tree
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)
root.right.left = Node(6)
root.right.right = Node(7)

# print the nodes at odd levels
print("Nodes at odd levels:")
print_odd_level_nodes(root)